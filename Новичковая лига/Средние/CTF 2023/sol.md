Еще мало кто решил задачку "CTF 2023":

Ключевые моменты, которые нужно было заметить:

1. Шифрование симметричное побайтовое с помощью xor. А значит для расшифровки текста достаточно просто повторить шифрование еще раз (xor отменится):

`python DiffusionCipher.py ctf2023.yaml.protected ctf2023.yaml key.json`

2. Выполнение кода займет несколько миллиардов лет из-за этого цикла:

```python
n0, n1, m0, m1 = 0, 1, 0, 1
n = 92153904885269267505545
while diffusionCycles <= n:
  n0, n1 = n1, a * n1 - b * n0
  m0, m1 = m1, x * m1 - y * m0
  diffusionCycles += 1
result = (m1 * n1) % N
```

3. В конце нас интересует ответ по модулю N, так что вспоминаем модульную арифметику из олимпиадного программирования. Это позволит избавиться от необходимости работать с числами из миллиардов знаков, что позволит сократить время выполнения всего до 3 миллионов лет

4. Операции внутри цикла подозрительно сильно напоминают умножение матриц:

`| n0 |   |  0  1  0  0 |   | n0 |`

`| n1 | = | -b  a  0  0 | * | n1 |`

`| m0 |   |  0  0  0  1 |   | m0 |`

`| m1 |   |  0  0 -y  x |   | m1 |`

Таким образом мы получаем что у нас есть цикл (* - умножение матриц, % - модуль по всем элементам):

```python
state = [0, 1, 0, 1]
for _ in range(n):
  state = (A * state) % N
```

Использование матриц может немного пугать, однако по сути этот цикл эквивалентен такому:

```python
a, b = 1, 2
for _ in range(n):
  a = b * a
```

Весь этот цикл можно оптимизировать до a * (b ** n). А для быстрого расчета b ** n можно использовать алгоритм быстрого возведения в степень, который возведет число (или матрицу) в степень n за O(log n). Главное не забывать про модули и не использовать numpy (у нас числа больше чем int64)!

Двух этих оптимизаций достаточно чтобы сократить время расшифровки до 1 секунды
